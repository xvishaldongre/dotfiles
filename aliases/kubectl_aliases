# Kubectl Aliases
## add aliases collection from https://github.com/ahmetb/kubectl-aliases
[ ! -f ~/.kube/aliases.sh ] && curl -fsSL "https://raw.githubusercontent.com/ahmetb/kubectl-aliases/master/.kubectl_aliases" > ~/.kube/aliases.sh 
source ~/.kube/aliases.sh

## add kubech - kubectl contexts/namespaces per shell/terminal
[ ! -f ~/.kube/kubech ] && curl -fsSL "https://raw.githubusercontent.com/DevOpsHiveHQ/kubech/master/kubech" > ~/.kube/kubech && chmod +x ~/.kube/kubech
source ~/.kube/kubech

alias k="kubectl"
# alias kc="kubectl-ctx"
alias kn="kubens"
alias x='kubechc | fzf | read -r context && kubechc $context && echo Switched to context "$context"'

function kc() {
  kubectl-ctx "$1" 2>/dev/null || ( \
    cat ~/.kube/config | yq -r '.contexts[] | .name + " " + .context.cluster' | \
    sed 's#^\(.*\) arn:\(.*\)/\(.*\)$#\1 \3#g' | sed 's/ /:/g' | fzf | cut -d ':' -f 1 | \
    read -r selected_context && \
    kubectl config use-context "$selected_context";
  )
}


## when using below aliases, print kubectl command and then execute it
function kubectl() { 
  if ! [[ "$@" =~ -A ]] && ! [[ "$@" =~ -o ]]; then
    echo "+ kubectl $@" >&2  # Print to stderr only if neither -A nor -o is present
  fi
  command kubecolor "$@"       # Always execute the kubectl command
}

## set default namespace
alias kn='kubectl config set-context --current --namespace'
## get events sorted by last timestamp
alias kgel='kubectl get events --sort-by=.lastTimestamp'
## get events sorted by creation timestamp
alias kgec='kubectl get events --sort-by=.metadata.creationTimestamp'
## get pod's descending events
function kger() { kubectl get events --sort-by=.lastTimestamp --field-selector involvedObject.name="$@" }
## get 'real' all
alias kgworld='kubectl get $(kubectl api-resources --verbs=list --namespaced -o name | paste -sd ",")'
## display all nodes resources request and limits
alias kgnr="k get nodes --no-headers | awk '{print \$1}' | xargs -I {} sh -c 'echo {} ; kubectl describe node {} | grep Allocated -A 5 | grep -ve Event -ve Allocated -ve percent -ve -- ; echo '"
## start a debug pod (including lots of troubleshooting tools)
alias kdebug="kubectl -n default run debug-$USER --rm -it --tty --image leodotcloud/swiss-army-knife:v0.12 --image-pull-policy=IfNotPresent -- bash"
## get pod's containers list
function kgpc() { kubectl get pod -o jsonpath="{.spec.containers[*].name}" "$@" && echo "" }
## ping a service, ex: 'kping whoami:8080'
alias kping='kubectl run httping -it --image bretfisher/httping --image-pull-policy=IfNotPresent --rm=true --'
## get existing pod's yaml without forbidden fields, ex: 'kyaml pod whoami'
function kyaml() { kubectl get "$@" -o yaml | kubectl-neat }
## display and delete failed pods in current namespace
alias krmfailed='kubectl delete pods --field-selector=status.phase=Failed'

# kubectl exec into a pod interactively
kei() {
  kubectl get pods -A | grep -v "using proxy" | tail -n +2 | grep -i running | fzf | awk '{print $1, $2}' | read namespace pod_name; 
  ## Try to start bash, if not available, try ash, if not available, try sh
  kubectl exec -i -t -n $namespace $pod_name -- sh -c 'bash || ash || sh || echo \"No shell available\"';
  unset namespace pod_name
}

## kubectl get secret interactively
ksd() {
    kubectl get secret -A | grep -v "using proxy"  | tail -n +2 | fzf -m | awk '{print $1, $2}' | while read -r namespace secret_name; do 
      echo "+ kubectl get secret $secret_name -n $namespace -o json | jq \".data | map_values(@base64d)\""
      kubectl get secret $secret_name -n $namespace -o json | jq ".data | map_values(@base64d)"
    done
    unset namespace secret_name
}

ksdf () {
  ksd | grep -i $1
}

## kubectl rollout restart deployment interactively
kdr() {
  kubectl get deployments -A | tail -n +2 | fzf -m | awk '{print $1, $2}' | while read -r namespace deployment; do
    ## kubectl rollout restart deployment "$deployment" -n "$namespace"
    echo "kubectl rollout restart deployment $deployment -n $namespace"
    kubectl rollout restart deployment "$deployment" -n "$namespace"
  done
}

## kubectl get deployment YAML interactively
kdy() {
  kubectl get deployments -A | tail -n +2 | fzf -m | awk '{print $1, $2}' | while read -r namespace deployment; do
    ## Save YAML file for the deployment
    echo "Downloading YAML for deployment $deployment in namespace $namespace"
    kubectl get deployment "$deployment" -n "$namespace" -o yaml | kubectl neat > "${deployment}_${namespace}.yaml"
  done
}